---
title: "Learning to Last (L2L) #0: Overview"
date: 2025-12-14
categories: [programming, l2l]
tags: [programming, l2l]     # TAG names should always be lowercase
---

## Introduction   

Welcome to Learning2Last (L2L), a blog series where I explore fundamental computer science concepts through hands-on projects. The goal is simple: learn by doing, and learn deeply.

Through practical challenges and real-world problems, I'll dive into programming fundamentals, algorithm optimization, database design, system architecture, and the underlying principles that make software efficient and reliable. Each project serves as both a learning exercise and a documentation of the journey—the mistakes, the insights, and the "aha" moments that come from working close to the machine.

This is my personal journal, written from my current knowledge and understanding. As such, it reflects my perspective at the time of writing and may contain errors, misconceptions, or incomplete explanations. That's part of the learning process—documenting not just the successes, but also the gaps in understanding that become apparent along the way.

This isn't about surface-level tutorials or quick wins. It's about building a foundation of knowledge that lasts: understanding why things work the way they do, how to optimize for performance, and what trade-offs matter in different contexts. By tackling increasingly complex problems, I aim to develop the kind of deep, practical understanding that only comes from getting your hands dirty with code.

So join me as I work through challenges, learn new languages, optimize algorithms, and explore the fundamentals of computer science—all these efforts to not be replaced by AI... at least not yet.

## Planned Projects

- [x] **[One Billion Row Challenge (1BRC) in C]({% post_url 2025-12-14-l2l-1brc %})** - Processing a billion weather measurements efficiently, exploring I/O bottlenecks, memory access patterns, and algorithmic optimization
- [ ] **Build a Key-Value Store** - Implement a simple database engine from scratch, learning about B-trees, write-ahead logs, and data persistence
- [ ] **Implement a HTTP Server** - Create a basic web server handling concurrent connections, parsing HTTP requests, and managing resources
- [ ] **Write a Compiler/Interpreter** - Build a simple language interpreter or compiler, exploring lexing, parsing, and code generation
- [ ] **Design a Distributed System** - Implement a distributed consensus algorithm (like Raft) or build a simple distributed key-value store
- [ ] **Optimize a Sorting Algorithm** - Deep dive into cache-aware algorithms, SIMD instructions, and parallel sorting techniques
- [ ] **Build a Search Engine** - Create an inverted index, implement ranking algorithms, and handle large-scale text processing
- [ ] **Implement Network Protocols** - Build TCP/IP stack components or implement application-layer protocols from scratch
- [ ] **Database Query Optimizer** - Write a query planner and optimizer, learning about cost models, indexing strategies, and execution plans
- [ ] **Memory Allocator** - Implement custom memory management, exploring malloc/free internals, fragmentation, and performance trade-offs
- [ ] **Custom Containerization** - Build a container runtime from scratch, learning about Linux namespaces, cgroups, filesystem isolation, and container orchestration fundamentals
- [ ] **Graph Algorithms Implementation from Scratch** - Implement fundamental graph algorithms (BFS, DFS, Dijkstra, A*, topological sort, etc.) from scratch, exploring data structures, traversal strategies, and optimization techniques

## Bibliography

- [ ] **Code** - Charles Petzold - Exploring how computers work from the ground up, from binary code and logic gates to the fundamental principles of hardware and software
- [ ] **Introduction to Algorithms (CLRS)** - Cormen, Leiserson, Rivest, Stein - Comprehensive reference on algorithms and data structures
- [ ] **The C Programming Language** - Kernighan & Ritchie - Essential guide to C programming fundamentals
- [ ] **Designing Data-Intensive Applications** - Martin Kleppmann - Deep dive into distributed systems, databases, and data processing
- [ ] **Computer Systems: A Programmer's Perspective** - Bryant & O'Hallaron - Understanding how programs interact with hardware and OS
- [ ] **Operating Systems: Three Easy Pieces** - Arpaci-Dusseau & Arpaci-Dusseau - Modern approach to OS concepts
- [ ] **Database System Concepts** - Silberschatz, Korth, Sudarshan - Comprehensive database systems textbook
- [ ] **Compilers: Principles, Techniques, and Tools** - Aho, Lam, Sethi, Ullman (Dragon Book) - Classic compiler design reference
- [ ] **Network Programming** - Various resources on TCP/IP, HTTP, and network protocols
- [ ] **Structure and Interpretation of Computer Programs (SICP)** - Abelson, Sussman, Sussman - Fundamental programming concepts and paradigms


<link rel="icon" type="image/png" href="../../assets/img/favicons/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="../../assets/img/favicons/favicon.svg" />
<link rel="shortcut icon" href="../../assets/img/favicons/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../../assets/img/favicons/apple-touch-icon.png" />

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
